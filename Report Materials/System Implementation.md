# System Implementation
* [**Stack architecture and system design**](#stack-architecture-and-system-design)
* [**Front End**](#front-end)
* [**Middle Tier**](#middle-tier)
* [**Back End**](#back-end)




## **Stack architecture and system design**






In this project, we used the front and back end separation method. The front end uses Angular to render and display the page. The more popular Spring Boot is used to implement back end services in the background. The front end obtains and uploads data through Ajax request, and the back end returns the result to show the corresponding rendering effect.    

&nbsp;

![image](https://user-images.githubusercontent.com/73413798/117672266-44324a00-b1dc-11eb-9ce6-cc82c385a90e.png)  



&nbsp;

The three-tier development is to divide the whole business application of the system into the presentation layer, the business logic layer and the data access layer, which is conducive to the development, maintenance, deployment and expansion of the system.

The layering is to achieve "high cohesion, low coupling". The idea of "divide and conquer" is adopted to divide problems into different solutions, which is easy to control, easy to extend, and easy to allocate resources.  


Presentation layer: responsible for direct interaction with the user, generally refers to the interface of the system, used for data entry, data display, etc. It means to only do the work related to the appearance display, and do not do the work that does not belong to him.  

Business logic layer: used to do some validation work, to better ensure the robustness of the program running. Such as the completion of data add, modify and query business; The specified text box is not allowed to enter an empty string, data format is correct and data type verification; The legitimacy of the user's authority and so on, through the above many judgments to decide whether the operation will continue to pass back, as far as possible to ensure the normal operation of the program.  

Data access layer: As the name suggests, it is dedicated to interacting with the database. Perform data addition, deletion, modification, display, etc. It is important to note that all Data objects are referenced only at this level, such as System.Data.SQLClient, and should not be referenced anywhere outside of the Data level.
   
   
   
   

![image](https://user-images.githubusercontent.com/73413798/117623119-fb5f9e80-b1a5-11eb-9eb6-a292a0f3dfda.png)

&nbsp;

* Angular is a popular and easy-to-use front end framework that leverages the power of a modern Web platform with high performance, offline, and zero installation. 


&nbsp;

![image](https://user-images.githubusercontent.com/73413798/117623140-01557f80-b1a6-11eb-9b1b-0208fa07491f.png)    

&nbsp;



* The Springboot framework is an open source application framework on the Java platform that provides a container with inversion of control features.    


&nbsp;


![image](https://user-images.githubusercontent.com/73413798/117623165-0adee780-b1a6-11eb-8edd-1f49635d08fc.png)   


&nbsp;

* For data storage, we chose the relatively popular MongoDB, which has good support for files and json type data.   
&nbsp;

&nbsp;

## **Front End**



## **Middle Tier**

&nbsp;
&nbsp;

### SpringBoot  

&nbsp;
SpringBoot is a new framework from the Pivotal team designed to simplify the initial setup and development process for new Spring applications.  
The framework uses a specific way to configure, eliminating the need for developers to define boilerplate configurations. As a popular Java framework, SpringBoot can be easily integrated with MongoDB. We can manipulate MongoDB with code by simply adding code and MongoDB related configuration in its configuration file Application.yml.   

&nbsp;

![image](https://user-images.githubusercontent.com/73413798/117576452-aaee2f80-b118-11eb-86a5-fb9da6202d4d.png)  

&nbsp;

At the same time, SpringBoot, as a server-side framework, integrates Tomcat container in spring-boot-starter-web. We just need to run it to provide services.  

&nbsp;

![image](https://user-images.githubusercontent.com/73413798/117576474-be999600-b118-11eb-8fa9-6d5f4cce6ab1.png)  

&nbsp;

The background adopts the hierarchical management method. Under the com.work package, AppStart serves as the startup entry, and we place it in the root directory. Then we put the object entity under the Entity package, with User information and Goal information, respectively. With the user Id, we can get all the targets under that user. The user Id and target Id will be stored in the database as unique indexes. They are strings automatically generated by MongoDB.  
&nbsp;

![image](https://user-images.githubusercontent.com/73413798/117577115-0e795c80-b11b-11eb-9dd5-de4c961ad8d1.png)  
 
 &nbsp;
 
The Server layer holds the service interface, and the specific implementation of the service is in the server.impl. We also created the underlying return information under the resp package.  

The RESTful architectural style dictates that meta-operations on data, namely CRUD(create, read, update, and delete) operations correspond to HTTP methods, respectively: GET is used to obtain resources, POST is used to create resources (which can also be used to update resources), PUT is used to update resources, and DELETE is used to DELETE resources, thus unifying the interface of data operation. All the work of adding, deleting and changing data can be done only through the HTTP method.

&nbsp;

That is:

Get (SELECT) : fetches resources (one or more) from the server.  

POST (CREATE) : Create a new resource on the server.  

PUT (UPDATE) : Updates the resource on the server (the client provides the complete resource data).  

PATCH (UPDATE) : Update the resource on the server (the client provides the resource data that needs to be modified).  

Delete (Delete) : Deletes a resource from the server.  


The Response class is returned as a uniformly formatted data format, with code identifying the return code. msg is the message prompt and data is the data returned. Finally, the Controller provides the interface path and the mapping implementation. It is in a RESTful style, and the return type is json, which is convenient for passing down and receiving.  
  


&nbsp;
&nbsp;



## **Back End**  

MongoDB is a database based on distributed file storage, which aims to provide scalable high-performance data storage solution for Web applications.  

It is characterized by high performance, easy to deploy, easy to use, and easy to store data. The main functional features are: 

* Collection-oriented storage, easy to store object type data.
* Mode freedom.
* Support for dynamic queries.
* Supports full indexes, including internal objects.
* Support for queries.
* Support replication and failover.
* Use efficient binary data storage, including large objects (like video, etc.).
* Automated fragmentation processing to support cloud level scalability
* The file storage format is BSON (an extension of JSON).
* Accessible via the network.  

&nbsp;

![image](https://user-images.githubusercontent.com/73413798/117675038-cae82680-b1de-11eb-8ddd-7c0001058be6.png)

&nbsp;

![image](https://user-images.githubusercontent.com/73413798/117674564-590fdd00-b1de-11eb-8f6d-b2a91cd5103f.png)

&nbsp;

We save the reward pictures into the database, and the user collects the pictures by completing the goal. The corresponding relationship is shown in the figure.


&nbsp;

![image](https://user-images.githubusercontent.com/73413798/117832356-000c7b80-b2a8-11eb-8583-ca6e528b114a.png)  



&nbsp;

The dao package implements database operations. They all inherit from MongoRepository, a parent class that provides support for various database operations. We can manipulate the database as if it were an object call.

&nbsp;

![image](https://user-images.githubusercontent.com/73413798/117616934-66a57280-b19e-11eb-82ff-9d97a8aa7ca1.png)

&nbsp;

For the interface document, we use the interface document generated by postman. postman is an interface testing tool that provides a lot of support for interface testing. All we need to do is log in and import the documentation we provide, so we can view the relevant interface request parameters and returns under the collection, as well as perform relevant tests locally.  

&nbsp;





