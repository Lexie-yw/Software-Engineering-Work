# Sprints & Project Management

&nbsp;

* [**Group working methods**](#group-working-methods)
* [**Communication channels and team roles**](#communication-channels-and-team-roles)
* [**Documentation of sprints**](#documentation-of-sprints)
* [**Team use of Git**](#team-use-of-git)

&nbsp;

## Group working methods

&nbsp;

Typical development models are:  

① Waterfall Model;  

② Incremental Model/Evolution/Iteration;   

③ Prototype Model;

④ Spiral model;   

⑤ fountAInmodel;  

⑥ Intelligent models;  

⑦ Hybrid Model


The fountain model was used in our group work. Fountain Model is a kind of model driven by user demand and object, which is mainly used to describe the object-oriented software development process. The model considers that the stages of the bottom-up cycle of software development process are mutually iterative and have no gap.   

Fountain models are mainly used in software development projects using object technology. The model considers that the stages of the bottom-up cycle of software development process are mutually iterative and have no gap. A piece of software is often reworked many times, with related objects adding incremental software components to each iteration. No gap means that there is no obvious boundary between various activities, such as analysis and design activities. Due to the introduction of the object concept, the expression of analysis, design, implementation and other activities only uses object classes and relations, so it is easier to realize the iteration and no gap of activities, so that its development naturally includes reuse.  


&nbsp;






![image](https://user-images.githubusercontent.com/73413798/117652063-49d06580-b1c5-11eb-825c-9604cc61057a.png)  



&nbsp;



The Fountain model is essentially a slightly improved version of its stricter relative – The Waterfall model. This model allows for the advancement from (and return to) various stages of software development regardless of whether or not enough tasks have been completed to reach it.  


&nbsp;




 Fountain Model Phases:
 * Analysis
 * Requirements Specification Design
 * Coding
 * Testing and Integration Operation
 * Maintenance or Evolution


&nbsp;


Advantages of the fountain model:  

Unlike waterfall models, fountain models need to start designing activities after the analysis activities and coding activities after the design activities. The phases of the model are not clearly demarcated and developers can develop simultaneously. Its advantage is that it can improve the software project development efficiency, save the development time, and adapt to the object-oriented software development process.  

&nbsp;

Disadvantages of the fountain model：  

Because the fountain model overlaps in each development stage, it requires a large number of developers during the development process, which is not conducive to project management. In addition, this model requires strict management of documents, which makes auditing more difficult, especially when various information, requirements, and materials may be added at any time.

Since the project development time is limited and our project focuses on the needs of users, we want to be able to carry out the project development more efficiently. So we chose the fountain model, so that we could clearly divide the work and each of us could focus on what we were responsible for. In addition, we set stage goals for everyone, and we will have regular meetings in the team channel to communicate progress and requirements, so as to ensure the smooth progress of the project.


&nbsp;

&nbsp;


## Communication channels and team roles

Because of COVID-19, we couldn't meet and communicate offline, so most of our work was done online, mainly on Teams and WeChat.

&nbsp;

![image](https://user-images.githubusercontent.com/73413798/117953594-bf187380-b348-11eb-955f-3604d78d54e8.png)  

&nbsp;

![image](https://user-images.githubusercontent.com/73413798/117953650-d0fa1680-b348-11eb-87af-f806be7c23bc.png)

  




&nbsp;



## Documentation of sprints

&nbsp;

## Team use of Git

Apart from teams, Git can be counted as our second communication tool. We created different branches to do tests separately and merged the successful working pieces into the main branch. As a version control and online collaboration tool, Git provided so much ease for our collaboration.

We followed a routine to always git fetch before starting working to see if there are new changes added by coworkers, and git push our own contribution with a commit message stating what scripts had been updated. When there was a real conflict, we would discuss through teams and then make the decision.

While we were making progress in our project, we were also getting more and more familiar with git and managed to store everything in an organized structure and streamlined our workflow. 

